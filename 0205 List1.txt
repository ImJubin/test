p.23


- 입력받은 정수를 1차원 배열에 저장하는 방법
eg. 


- 배열 원소의 합 s 계산하기

arr 0 1 2 3 4 5 n=6
    2	7 5 3 1 4

s 0 --------------- 22


s = 0
for i in range(N):  # for x in arr
    s += arr[i]	#	s += x


[참고] 배열연산

- 배열 원소의 합 s 계산하기

	     0 1 2 3 4 5  n = 6
	arr 2 7 5 3 1 4
s     0 -----------------------22

for i in range(N):  # for x in arr:
s += arr[i]		 #	s += x


- 배열 원소 중 최댓값 max_v 찾기

arr  0 1 2 3 4 5 n=6
      2	7 5 3 1 4

max 2 7			max_v 7

max.v = arr[0] # 첫 원소를 최대로 가정
for i 1 부터 n-1까지
	if max-v<arr[i]
	  max-v = arr[i]

for i in range(1,n):
	if max_v < arr[i]:
		max_v = arr[i]  #arr[i]가 더 크면 max_v 갱신


- 배열 원소 중 최댓값의 인덱스 Max_idx 찾기

arr  	0 1 2 3 4 5 n=6
      	2 7 5 3 1 4
	
max_idx 0 1

max_idx = 0  #첫 원소를 최대로 가정
for i in range(1,N):
	if arr[max_idx] < arr[i]  # 더 큰 값을 만나면
	max_idx = i			# max_idx 갱신

------------------------------------------------------------------------

<연습문제1>

N개의 양의 정수에서 가장 큰 수와 가장 작은 수의 차이를 출력하라.

[입력]

첫 줄에 테스트 케이스의 수 T가 주어진다. (1 ≤ T ≤ 50 )
각 케이스의 첫 출에 양수의 개수 N이 주어진다. (5 ≤ N ≤ 1000)
다음 줄에 N개일 양수 ai가 주어진다. ( 1 ≤ ai≤ 1000000 )

[출력]

각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 빈칸에 이어 답을 출
력한다.

[입력 예시]

3
5
477162 658880 751280 927930 297191
5
565469 851600 460874 148692 111090
10
784386 279993 982220 996285 614710 992232 195265 359810
919192 158175
[출력 예시]

#1 630739
#2 740510
#3 838110


답안

T = int(input())
for tc in range(1, t+1):
    N = int(input())
    arr = list(map(int, input().split()))

    max_v = arr[0] # 첫 원소를 최댓값으로 가정
    min_v = arr[0] # 첫 원소를 최솟값으로 가정

    for i in range(1, n):
        if max_v < arr[i]: 		# arr[i] > max_v (다음 연산식과 비교식 순서를 맞출 것)
            max_v = arr[i]
        if min_v > arr[i]:
            min_v = arr[i]
    
    print(f'#{tc} {max_v-min-v}')



<연습문제2>

배열 활용 예제 : Gravity
• 상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이
중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그
낙차를 리턴 하는 프로그램을 작성하시오.
• 중력은 회전이 완료된 후 적용된다.
• 상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며
벽에서 떨어져서 쌓인 상자는 없다.
• 상자의 가로, 세로 길이는 각각 1이다.
• 방의 가로길이는 100이며, 세로 길이도 항상 100이다.
• 즉, 상자는 최소 0, 최대 100 높이로 쌓을 수 있다.
• 상자가 놓인 가로 칸의 수 N, 다음 줄에 각 칸의 상자 높이가 주어진다.

♡ 그림 설명
• 아래 예) 총 26개의 상자가 회전 후, 오른쪽 방 그림의 상태가 된다. A 상자의
낙차가 7로 가장 크므로 7을 리턴하면 된다.
• 회전 결과, B상자의 낙차는 6, C상자의 낙차는 1이다.

입력 예시
9
742006070


답안

입력예시에서 

모든 숫자에 대해
for i in range(n)

7보다작은 애들 = 7
4보다 ~           = 5
2보다 ~	      = 4

오른쪽에 본인보다 작은 숫자를 셈.

그럼

i상자의 낙차는
a[i]의 오른쪽에 있는 더 작은 a[i] 원소의 수.

주어진 상황에서 최소보다 작게 출력하면 되니까

max_v = 0

for i 는 0부터 n-1까지

오른쪽에 있는 더작은애들의 개수 = cnt라고 가정하자.
cnt = 0
	for j: i+1 ,,,, n-1 까지 감
	if arr[i] > arr[j]
	cnt += 1

	if max-v < cnt
	   max-v = cnt

(???????어렵다,,,)


--------------------------------------------------------------------------------------------------------

버블정렬

정렬
• 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 홈은
그 반대의 순서대로(내림차순 : descending) 재배열하는 것
 키
• 자료를 정렬하는 기준이 되는 특정 값

♡ 대표적인 정렬 방식의 종류
• 버블 정렬 (Bubble Sort)
• 카운팅 정렬 (Counting Sort)
• 선택 정렬 (Selection Sort)
• 퀵 정렬 (Quick Sort)
• 삽입 정렬 (Insertion Sort) (우리 과정에선 빠짐)
• 병합 정렬 (Merge Sort)

♡ APS 과정을 통해 자료구조와 알고리즘을 학습하면서 다양한 형태의 정렬을
학습하게 된다.

<<<인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식>>>

♡ 정렬 과정
• 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막
자리까지 이동한다.
• 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
• 교환하며 자리를 이동하 모습이 물 위에 올라오는 거품 모양과
같다고 하여 버블 정렬이라고 한다.

♡ 시간 복잡도

· O(n2)


♡ [55, 7, 78, 12, 42]를 버블 정렬하는 과정 (오름차순)
• 첫 번째 패스 (그림 참고)

큰 걸 오른 쪽으로 보냄. (자리 바꿈)
그다음 공간은 그대로
그다음 공간은 큰 걸 오른쪽으로 보냄(자리 바꿈)
그다음 공간은 큰 걸 오른쪽으로 보냄(자리 바꿈)
.....

전체 구간에서 가장 큰 수가 오른쪽 하단 끝에 와있음
정렬된 원소가 됨. (=78)
78의 왼쪽 원소는 미정렬 원소가 됨(7 55 12 42)

나머지 미정렬 원소에 대하여 또 정렬 시작

• 두 번째 패스 (그림 참고)

그대로
자리바꿈
자리바꿈
정렬된 원소 55
55의 왼 원소는 미정렬 원소가 됨 ( 7 12 42)

• 세 번째 패스
됨

• 네 번째 패스
7 12 비교 ㄱㄱ
그대로

• 정렬 끝

7 12 42 55 78

풀이

0 1  2   3    4   n

n-5 n-4 n-3 n-1 .....


BubbleSort(a, N)
    for i : N-1 -> 1
	for j : 0 -> i-1
	    if a[j] > a[j+1]
		a[j] <- > a[j+1]

# 정렬할 배열과 배열의 크기
# 정렬할 구간의 끝
# 비교할 원소 중 왼쪽 원소의 인
# 왼쪽 원소가 더 크면
# 오른쪽 원소와 교환


배열을 활용한 버블 정렬
• 앞서 살펴 본 정렬 과정을 코드로 구현하면 아래와 같다. (오름차순)

def BubbleSort(a, N) : # 정렬할 List, N 원소 수
for i in range(N-1, 0, -1) : # 범위의 끝 위치
for j in range(i) : # 비교할 왼쪽 원소 인덱스 j
if a[j] > a[j+1]:
a[j], a[j+1]ya[j+1], a[j]



<코드 제공해주심>

def BubbleSort(a, N) : 	# 정렬할 List, N 원소 수
    for i in range(N-1, 0, -1) : # 범위의 끝 위치
        for j in range(i) :		# 비교할 왼쪽 원소 인덱스 j
            if a[j] > a[j+1] :
                a[j], a[j+1] = a[j+1], a[j] 


def bubblesort(arr, N):			# 오름차순
	for i in range(n-1, 0, 1):		# 정렬구간의 끝 i
		for j in range(i):		# 비교하는 왼쪽 원소의 인덱스(0부터 구간마지막 인덱스 -1)
			# 왼쪽 원소가 크면 자리 교환
				if arr[j] > arr[j+1]:
					a[j], a[j+1] = a[j+1], a[j] 




-----------------------------------------------------------------끝------------------------------------------


P.4
IM 수준 : 조건, 반복, 인덱스, 연산 ...
(LIST 배열, 2차원 등)

P.16시간복잡도
반드시알아야함

log n

for i in range(n)
	for range(n)

n제곱번 돈다.=(n^2)

*정렬할 때 파악해야 할 것

- 어떤 정렬 인지 > 버블
- 시간복잡도 > N^2
(등차수열 n, n-1, ,,,,합)
- 안정 정렬 / 불안정 정렬

버블정렬은 안정정렬일까?
안정정렬이다. 둘이 값이 같을 때 바뀌지 않기 때문.
특정 기준에 따라 두수비교를 끝까지 반복함으로서 맨끝부터 정렬됨.


선택정렬은 안정정렬일까?
아니, 불안정 정렬이다.
n^2

최솟값찾기

n만큼 돌고 최솟값나옴.
n-1만큼 돌고 최솟값 나옴
n-2만큼 ....



----------------------------------------------------------------------------------------
problem1.py 풀이

#평균 = 총합 / 리스트 길이
#       >sum, len 없이 총합, 길이를 구하려면? 반복문을 돌아야해(구조)
#       >그 총합(sum_list)과 길이(lengh)는 변수가 필요하겠군(data)
#최소, 최대
#       >min max 없이 최소 치대 구하려면? 반복문을 돌아야 해 (구조)
#       >최소, 최대 변수가 필요하겠군(data)

#  아 그럼 반복문은 한 번만 돌아도 그 안에서 다 구할 수 있겠군

def analyze_likes(weekly_like_list):
    sum_list = 0
    size_list = 0
    min_list = max_list = weekly_like_list[0]

    for number in weekly_like_list:
        size_list += 1
        sum_list += number

        if number < min_list:
                min_list = number
        
        if number > max_list:
                max_list = number
    
    return (sum_list/size_list, max_list-min_list)






problem2.py












































