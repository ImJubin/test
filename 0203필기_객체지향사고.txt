절차 지향 프로그래밍

a=5
b=10

def sum(a, b):

데이터나 기능을 전역적으로 관리
코드가 길어졌을 때 곤란해짐. >> 카테고라이징으로 해결! (OOP, 설계 필요)




객체지향사고

사람 안에 name, age와 이와 관련된 기능(메서드) 포함

class person:
	def __init__(self, name, age):
		self.name
(더써야함)

객체 지향 프로그래밍 특징

프로그램을 데이터(변수)와 그 데이터를 처리하는 함수(메서드를) 하나의 단위(객체)로 묶어서 조직적으로 관리
데이터와 메서드의 결합

주방도구(프라이팬, 칼), 재료(야채, 고기), 행동(볶기, 썰기)를 각각 별개로 생각하지 않고, "볶음밥 기계"라는 객체로 만들어 놓고 그 기계가 알아서 해당 행동과 재료를 관리하는 방식

절차지향 & 객체지향

절차지향

데이터와 해당 데이터를 처리하는 함수(절차)가 분리
함수 호출의 흐름이 중요

"어떤 순서로 처리할까?"

객체 지향
데이터와 해당 데이터를 처리하는 메서드(함수)를 하나의 객체(클래스)로 묶음

객체 간 상호작용과 메시지 전달이 중요함

"어떤 객체가 이 문제를 해결할까?"
"이 객체는 어떤 속성과 기능을 가질까?"

객체지향 - "데이터가 살아나다"

객체 지향은 수동적인 데이터가 능동적인 객체로 변화한 것

절차 지향에서는 데이터가 함수의 매개변수로 전달되어 처리되는 수동적 존재
객체 지향에서는 데이터와 해당 데이터 처리하는 메서드가 하나의 객체로 통합되어 스스로 기능을 수행하는 능동적 존재가 됨.

이는 코드의 구조화와 재사용성을 높이는 동시에,
실제 세계 모델링 방식과 더 유사한 프로그래밍을 가능하게함.

절차지향과 객체지향은 대조되는 개념이 아니다.

객체 지향은 기존 절차 지향을 기반으로 두고
보완하기 위해 객체라는 개념을 도입해

* 상속, 코드 재사용성, 유지보수성 등의 이점을 가지는 패러다임

	CF. 상속(개념의 상속. 객체의상속이아님. 실재하지 않음.)

	맹수(각 하위 개념의 공통적인 기능과 상속을 가짐. 추상적) >>어흥 >> (아아,어어,하하)

high 프로그래밍, 사람이 이해하기 좋음
low 레지스터 0/1, 기계가 이해하기 좋음, 기계어(Assembly)


객체와 클래스

객체 (object)
실제 존재하는 사물을 추상화한 것
"속성"과 "동작"을 가짐
->> 변수, 매서드
eg. 루비 = 강아지
루비.종
루비.짖기()


예를 들어 "강아지" 객체는 이름, 종, 나이(특징)과, 짖기, 뛰기(행동) 등으로 표현

클래스(class)
객체를 만들기 위한 설계도
데이터와 기능을 함께 묶는 방법을 제공
파이썬에서 타입을 표현하는 방법

eg. 가수(클래스) , 아이유(객체)

클래스로부터 여러 개 객체를 쉽게 찍어낼 수 있음


객체 특징
속성(attribute)
객체의 상태/데이터

메서드
객체의 행동/기능

고유성
각 객체는 고유한 특성을 가짐


클래스 기초

클래스
데이터와 기능을 하나의 틀로 묶어 관리하는 방법
사용자 정의 객체를 만드는 수단이자 속성과 메서드를 정의


클래스 정의
class 키워드
클래스 이름은 파스칼 케이스(Pascal Case)방식으로 작성

class MyClass:
	pass

클래스 예시
__init__메서드는 ' 생성자 메서드'로 불리며,
새로운 객체를 만들 때 필요한 초기값을 설정 (메서드 챕터에서 진행)

	eg. person() 생성자 (객체, 즉 인스턴스를 생성)


개발자 실제로 호출 진행 xx !!! 자동으로 호출됨.

class Person:
    def __init__(self, name, age):
        self.name = name  # 인스턴스 속성
        self.age = age  # 인스턴스 속성

    def introduce(self):
        print(f'안녕하세요. 저는 {self.name}, 나이는 {self.age}살입니다.')

인스턴스
클래스를 통해 생성된 객체

인스턴스 예시
클래스가 설계도라면, 인스턴스는 그 설계도로부터 실제로 만든 '개별 물건'
person("Alice", 25)라고 하면 person이라는 설계도로부터 이름이 alice이고 나이가 25인 '사람 객체'가 탄생

클래스와 인스턴스

가수(클래스)

아이유는 객체다 (0)
아이유는 인스턴스다 (세모)
아이유는 가수의 인스턴스다(0)

누구의 인스턴스인지 명확하게 표현해야함.

클래스를 만든다. == 타입을 만든다.

클래스와 인스턴스

변수 name의 타입은 str클래스다.
변수 name은 str 클래스의 인스턴스이다.
우리가 사용해왔던 데이터 타입은 사실 모두 클래스였다.

name = 'Alice'
print(type(name)) #class str

인스턴스와 메서드
"hello".upper()

str의 인스턴스는 "hello"
.upper은 string클래스로 만들어진 인스턴스의 함수.

문자열.대문자로()
객체.행동()
인스턴스.메서드()

' ', 'hello', '파이썬'

[1, 2, 3], [1]. [], ['hi']

리스트타입(클래스)의 객체(인스턴스)

[1, 2, 3].sort()

리스트.정렬해()
객체.행동()
인스턴스.메서드()

하나의 객체(object)는
특정 클래스의 인스턴스(instance)이다.

클래스 구조
클래스 구조(1/3)
생성자 메서드
인스턴스 생성시 자동 호출되는 특별한 메서드
__init__이라는 이름의 메서드로 정의
인스턴스 변수의 초기화 담당

class Circle:
    #클래스 변수(속성)
    pi = 3.14

    # 생성자 메서드
    def __init__(self, redius):
        self.radius = redius

클래스 구조 (2/3)

인스턴스 변수(속성)
각 인스턴스별 고유한 속성
self.변수명 형태로 정의
인스턴스마다 독립적인 값 유지

클래스 변수와 인스턴스 변수
클래스 변수와 동일한 이름으로 인스턴스 변수 생성 시
클래스 변수가 아닌 인스턴스 변수에 먼저 참조하기 됨.

calss.class_variable로 클래스 변수 참조 가능


메서드
메서드란
클래스 내부에 정의된 함수로,
해당 객체가 어떻게 동작할지를 정의

메서드 종류
1. 인스턴스 메서드 인스턴스.메서드()
2. 클래스 메서드
3. 스태틱 메서드

1. 인스턴스 메서드

클래스로부터 생성된 각 인스턴스에서 호출할 수 있는 메서드
>인스턴스의 상태를 조작하거나 동작을 수행

인스턴스메서드 구조
클래스 내부에 정의되는 메서드의 기본
반드시 첫 번째 인자로 인스턴스 자신(self)을 받음
인스턴스의 속성에 접근하거나 변경 가능

 class MyClass:

	def instance_method (self, arg1, ...):
		pass

*self는 매개변수 이름일 뿐이며 다른 이름으로 설정 가능
하지만 다른 이름을 사용하지 않을 것을 강력히 권장

self 동작 원리 (1/2)

upper 메서드를 사용해 문자열 'hello'를 대문자로 변경
'hello'.upper()
하지만 실제 파이썬 내부 동작은 다음과 같이 진행됨
str.upper('hello')
str클래스가 upper 메서드를 호출했고,
그 첫번째 인자

생성자 


2. 클래스 메서드

클래스가 호출하는 메서드
클래스 변수를 조작하거나 클래스 레벨의 동작을 수행

클래스 메서드 구조
@classmethod 데코레이터를 사용하여 정의
호출 시, 첫번째 인자로 해당 메서드를 호출하는 클래스(cls)가 전달됨
클래스를 인자로 받아 클래스 속성을 변경하거나 읽는 데 사용

class MyClass:
	@classmethod
	def class_method(cls, arg1, ...):
		pass

*cls는 매개변수 이름일 뿐이며 다른 이름으로 설정 가능
하지만 다른 이름을 사용하지 않을 것을 강력히 권장

------------------------------------------------------------
class Person:
    population = 0

    def __init__(self, name):
        self.name = name
        Person.increse_population()

    @classmethod
    def increse_population(cls):
        cls.population += 1

person1 = Person('Alice')
person2 = Person('Bob')

print(Person.population)  # 2


Person.increse_population()
print(Person.population) # 3

--------------------------------------------------------------

3. 스태틱 메서드

정적 메서드
클래스, 인스턴스와 상관없이 독립적으로 동작하는 메서드
@staticmethod 데코레이터를 사용하여 정의
호출 시 자동으로 전달받는 인자가 없음 (self, cls 받지 않음)
인스턴스나 클래스 속성에 직접 접근하지 않는, '도우미 함수'와 비슷한 역할
인자를 외부에서 가져옴.

class MyClass:
	
	@staticmethod
	def static_method(arg1, ...):


수학에 관련 기능을 담은 MathUtils 클래스에서 덧셈 기능을 제공하는 예시

class MathUtils:
	@staticmethod
	def add(a, b):
		return a + b

print(MathUtils.add(3, 5))

메서드 활용

메서드 정리
인스턴스 메서드
인스턴스의 상태를 변경하거나, 해당 인스턴스의 특정 동작을 수행

클래스 메서드
인스턴스 상태에 의존하지 않는 기능을 정의
클래스 변수를 조작하거나 클래스 레벨의 동작을 수행

스태틱 메서드
클래스 및 인스턴스와 관련이 없는 일반적인 기능을 수행

누가 어떤 메서드를 사용해야 할까(1/2)

클래스가 사용해야 할 것
클래스 메서드
스태틱 메서드

인스턴스가 사용해야 할 것 
인스턴스 메서드

인스턴스가 클래스메서드 사용하면 안되는 이유


예시 클래스로 클래스와 인스턴스가 각각 모든 메서드를 호출해보기
클래스는 모든 메서드를 호출할 수 있음
* 하지만 클래스는 클래스 메서드와 스태틱 메서드만 사용하도록 한다

할 수 있다 != 써도 된다
각자의 메서드는 OOP 패러다임에 따라
명확한 목적에 따라 설계된 것이기 때문에
클래스와 인스턴스 각각 올바른 메서드만 사용한다.

클래스와 인스턴스 간의 이름 공간
클래스를 정의하면, 클래스와 해당하는 이름 공간 생성
인스턴스를 만들면, 인스턴스 객체가 생성되고 독립적인 이름 공간 생성
인스턴스에서 특정 속성에 접근하면, 인스턴스 -> 클래스 순으로 탐색

독립적인 이름 공간을 가지는 이점
각 인스턴스는 독립적인 메모리 공간을 가지며, 클래스와 다른 인스턴스 간에는 서로의 데이터나 상태에 직접적인 접근이 불가능

객체 지향 프로그래밍의 중요한 특성 중 하나로,
클래스와 인스턴스를 모듈화하고 각각의 객체가 독립적으로 동작하도록 보장

이를 통해 클래스와 인스턴스는 다른 객체들과의 상호작용에서
서로 충돌이나 영향을 주지 않으며 독립적으로 동작할 수 있음

코드의 가독성, 유지보수성, 재사용성을 높임

매직 메서드
Double undercore('__')가 있는 메서드는 특수한 동작을 위해 만들어진 메서드
인스턴스 메서드
특정 상황에 호출됨

__str__(self)
내장함수 print에 의해 호출되어 객체 출력을 문자열 표현으로 변경
class Circle:
	def __inti

데코레이터
다른 함수의 코드를 유지한 채로 수정하거나 확장하기 위해 사용되는 함수
언제 쓸까?

-------------------------------------------
# 데코레이터 정의
def my_decorator(func):
    def wrapper():
        # 함수 실행 전에 수행할 작업
        print('함수 실행 전')
        # 원본 함수 호출
        result = func()
        # 함수 실행 후에 수행할 작업
        print('함수 실행 후')
        return result
    return wrapper
-------------------------------------------

0203

			동적
code   / data / heap / stack
                    (객체)
			     (함수시행)
AB메서드





