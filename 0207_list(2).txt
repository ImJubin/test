기본

APS(Algorithm Problem Solving)
2. List 2
• 2차원 배열
• 델타
• 부분집합
• 검색
• 이진 검색 (Binary Search)
• 선택 정렬 (Selection Sort)
• 셀렉션 알고리즘 (Selection Algorithm)

♡2차원 배열의 선언
• 1차원 List를 묶어놓은 List
• 2차원 이상의 다차원 List는 차원에 따라 Index를 선언
• 2차원 List의 선언 : 세로길이(행의 개수), 가로길이(열의 개수)를 필요로 함
• Python 에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함

arr = [[0,1,2,3],[4,5,6,7]] (2행 4열의 2차원 List)

arr    0 1 2 3 열
0	0 1 2 3
1	4 5 6 7
행

[참고] 2차원 배열

• 입력을 2차원 배열에 저장하기


3
1 2 3
4 5 6
7 8 9

N = int(input)
arr = [list(map(int, input().split())) for _ in range(N)]


(붙어서 들어오는)

3
123
456
789

N = int(input)
arr = [list(map(int, input())) for _ in range(N)]


cf. 스트링 활용하면 ['123', '456', '789']

[참고] 2차원 배열

0으로 채워진 3x4 배열 만들기
0 1 2 3
0 0000
1 0000
2 0000

arr = [[0] * 4 for _ in range(3)]

arr ㅁ -->>> ㅁㅁㅁㅁㅁ

	ㅁ ->
	ㅁ ->
	ㅁ ->

2차원 배열의 접근

♡배열 순회
• nX m 배열의 n*m 개의 모든 원소를 빠짐없이 조사하는 방법

♡행 우선 순회 ----------->

# i 행의 좌표
# j 열의 좌표
for i in range(n):
	for j in range(m):
		f(array[i][j]) #필요한 연산 수행

x y 안쓰는 이유 - 혼동을 피하기 위해서


2차원 배열의 합

• N x M 배열의 크기와 저장된 값이 주어질 때 합을 구하는 방법
[입력 예시]

3 4
1 7 2 8
6 2 9 3
5 7 4 2

N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]


s=0
	for i in range(N):
		for j in range(M):
			s += arr[i][j]


행의 합중 최댓값??

max.v = 0
row.s (행의 합 초기화 해놓고, 행을 돌아다니며 합을 구해보자.
한 행이 끝나면, max_v < row_s: 식으로)


2차원 배열의 접근
♡ 열 우선 순회
# i 행의 좌표
# j 열의 좌표

C

2

for j in range(m) :
for i in range(n) :
f(array[i][j]) # 필요한 연산 수행

i 먼저 하고 싶으면
array[j][i]로 하면 됨.


지그재그순회

# i 행의 좌표
# j 열의 좌표

for i in range(n) :
	for j in range(m) :
		f(array[i][j +(m-1-2*j) * (i%2)])


if i%2 == 0
	for j in range(m):
else:
	for j in range(m-1, 1, -1)


j는 증가하는 방향(참으로 접근)
왼쪽은 3 2 1 0 으로 만들어야 함. 0 2 4 번째일때
m-1부터 시작해서 점점 작아져야 함. 1 3 5 번째 일 때
그래서 m-1 -j -1
m-1-2j +j

원리만 이해하기 !
외워서 시험에 나올 정도는아님


델타

2차원 배열의 활용

♡ 델타를 이용한 2차원 배열 탐색
• 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
• 인덱스 (,j)인 칸의 상하좌우 칸 (ni, nj)

(그림참고)

di[] ← [0, 1, 0, -1] # 방향별로 더할 값
djl] - [1, 0, -1, 0]

for k : 0 -> 3
	ni <- i + di[k]
	nj <- j + dj[k]


	i-1
	j+0

i+0		i+0
j-1		j+1

	i+1
	J+0

맨오른쪽부터 0 1 2 3


--------------------------------------------------------------------------------------
예시문제

di = [0, 1, 0, -1] #오른 쪽부터 시계 방향으로
dj = [1, 0, -1, 0]

N = 2
M = 3
for i in range(N):
    for j in range(M):
        for dir in range(4):
            ni = i + di[dir]
            nj = j + dj[dir]
            if 0<=ni<N and 0 <=nj<M:
                print(ni, nj)
---------------------------------------------------------------------------------------

델타를 이용한 2차원 배열 탐색 (1)
• 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법

arr[0 .. N-1][0 ... N-1] # NxN 배열
di[l [0, 1, 0, -1] #
dj[]
for i : 0 -> N-1

for j : 0 -> N-1 :
for d in range(4) :
ni i + di[d]
nj < j + dj[d]
if 0 <= ni<N and 0 <= nj<N # 유효한 인덱스면
f(arr[ni][nj])


♡ 델타 응용
ex) NxN 배열에서 각 원소를 중심으로, 상하좌우 k칸의 합계 중 최대값 (k=2)

max_v = 0
for i in range(N):
	for j in range(N):
		s = arr[i][j]		#i,j를 중심으로
		for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]:		# 각 방향
			for c in range(1, k+1)			# 거리별
				ni, nj = i+di*c, j+dj*c
				if 0 <= ni<N and 0 <= nj<N:
					s += arr[ni][nj]
	if max_v < s:
	max_v = s



♡ 전치 행렬
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[O])
arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬


for i in range(3) :
	for j in range(3) :		# for j in ranage(i):인경우
		if i <j :				#	if문 필요 없음
			arr[i][j], arr[j][i] = arr[j][i], arr[i][j]


ij 크기에 따라 접근하는 원소 비교(N*M)

i<j

i>k

i==j

N-1-i === j

for i in range(N):
	for j in range(N):
		if~~~~~~:

for i in range(N):
	f(arr[d][N-1-i])


--------------------------------------------------------------------
연습문제

    # s = 0
    # for i in range(5)
        # s += A[i][i]
        # s += A[i][4-i]

        # s -=A[5//2][5//2] 왜냐하면 정 가운데는 두번 더해지기 때문. 즉, 행과 열 크기가 홀수인 경우 필요.
        # *(N%2)
N = int(input())
arr = [list(map(int, input().split())) for _  in range(N)]
total = 0
for i in range(N):
    for j in range(N):
        for di, dj in [[0,1], [1,0], [0,-1], [-1,0]]:
            ni = i + di
            nj = j + dj
            if 0<=ni<N and 0<=nj<N:
                total =+ abs[arr[ni][nj] - arr[i][j]]

print(total)

** 우선순위는 2차열 배열과 델타임!
----------------------------------------------------------------------------

♡ 부분집합 합문제

유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서
그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제

예를 들어, [-7,-3, -2, 5, 8]라는 집합이 있을 때, [-3, -2, 5]는 이 집합의
부분집합이면서 (-3)+(-2)+5=0이므로 이 경우의 답은 참이 된다.



[1,2,3]

[]

[1][2][3]

[1,2][2,3][1,3]

[1,2,3]

#1. 부분집합을 먼저 만든다.



♡부분집합의 수
• 집합의 원소가<객일 때, 공집합을 포함한 부분집합의 수는 2^n개이다.
• 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를
모든 원소에 적용한 경우의 수와 같다.


예

{1, 2, 3, 4}
→ 2×2×2×2=16가지

arr 123
[	]
[     3 
[  2   ]
[  2,3 ]
[ ]
[3 1]
[ 1, 2 ]
[ 1, 2, 3 ]


♡ 각 원소가 부분집합에 포함되었는지를 loop 이용하여 확인하고 부분집합을
생성하는 방법


bit = [0, 0, 0, 0]
for i in range(2) :
	bit[0] = i	#0번 원소
	for j in range(2) :		
		bit[1] = j		# 1번 원소
		for k in range(2) :
			bit[2] = k	# 2번 원소
			for I in range(2)
				bit[3] = I  # 3번 원소
				print_subset(bit)	# 생성된 부분집합 출력


----------------------------------------------------------------------------
실습 subject1.py

bit = [0] *3
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
        bit[2] = k
        # print(bit)
        s = 0
        for b in range(3):
            if bit[b]:
                print(a[b], end=' ') #부분집합에 포함된 원소
                s += a[b]
        print(bit, s)

-------------------------------------------------------------------------------
♡ 비트 연산자

&	비트 단위로 AND 연산을 한다.
ㅣ	비트 단위로 OR 연산을 한다.
<<	피연산자의 비트 열을 왼쪽으로 이동사킨다.
>>	피연산자의 비트 열을 오른쪽으로 이동시킨다.

 << 연산자
• 1 << n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

(#1. 왜 2^N일까?
ㅁㅁㅁㅁㅁㅁㅁㅁㅁ
	...	 2^2    2^1 2^0

n번 비트가 1인 값, 2의 n제곱에 해당한 값이 됨...)

 & 연산자
• i & (1 << j) : i의 j번째 비트가 1인지 아닌지를 검사한다.


♡ 보다 간결하게 부분집합을 생성하는 방법
Python 코드 예

arr = [3,6,7,1,5,4]
n = len(arr)		# n : 원소의 개수


for i in range(1 << n) : # 1.  << n : 부분 집합의 개수
	for j in range(n):  # 2. 원소의 수만큼 비트를 비교함
		if i & (1 << j): # i의 j번 비트가 1인경우
			print(arr[j], end=", ") # j번 원소 출력

	print()
print()

----------------------------------------------------------------------
<<<subject1>>>

bit = [0] * 3
for i in range (2):
	bit[0] = i
	for j in range(2):
		bit[1] = j
		for k in range(2):
			bit[2] = k
			print(bit)
			# print(bit)
			s = 0 	# 부분 집합의 합
			for b in range(3):
            			if bit[b]:
                	int(a[b], end=' ') # 부분집합에 포함된 원소
			s += a[b]
			print(bit, s)

------------------------------------------------------
강사님 예시

arr [123]

000	0
001	1
010	2
011	3
100	4
101	5
110	6
111	7

0부터 2^N-1을 i라 하고.
[1 2 3]
b0 이 0, b1이 1, b2가 2번인덱스로...
i의 j번 비트를 검사해! <<if식에서,
0이 아니면 (001 얜 포함된 원소니까  j출력
011 얜 포함된 원소니까 출력)
통과 / 출력 


-------------------------------------------------------------------끝------------------

시험 평가 하기 좋은 주제이기 때문에 풀이 꼭 이해하기 1!!!

#1. swea2805. 농작물수확하기.
#2. swea1210. ladder.

순열 [1,2,3]

몇 개 ?????
(3,2) =! (2,3)

조합 (1,2) (1,3) (2,3)


백준
n과 m


A 비선형
특정 시점 의사결정할 때,


Dfs (다 갔으면 돌아올 때 빼고,,,, 다음가지로 ,,,)

Bfs l l


이동거리가 K

















































